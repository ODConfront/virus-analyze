# 汇编中的C代码结构

1.全局与局部变量 
全局变量通过内存地址引用，局部变量通过栈地址引用
全局变量调用：
C:
int x = 1;
int y = 2;
void main()
{
  x = x+y;
  printf("Total=%d\n",x);
}
Asm:
mov eax,dword_40CF60
add eax,dword_40C000
mov dword_40CF60,eax
mov ecx,dword_40CF60
push exc
push offset aTotalD; "total=%d\n"
call printf
局部变量调用：
C:
void main()
{
  int x = 1;
  int y = 2;
  x = x+y;
  printf("Total=%d\n",x);
｝
Asm:
mov dword ptr[ebp-4],1
mov dword ptr[ebp-8],2
mov eax,[ebp-4]
add eax,[ebp-8]
mov [ebp-4],eax
mov ecx,[ebp-4]
push ecx
push offset aTotalD; "total=%d\n"
call printf

2.反汇编算术操作
C:
int a = 0;
int b = 1;
a = a + 11;
a = a - b;
a--;
b++;
b = a % 3;
Asm:
mov [ebp+var_4],0
mov [ebp+var_8],1
mov eax,[ebp+var_4]
add eax,0Bh
mov [ebp+var_4],eax
mov ecx,[ebp+var_4]
sub ecx,[ebp+var_8]
mov [ebp+var_4],ecx
mov edx,[ebp+var_4]
sub edx,1
mov [ebp+var_4],edx
mov eax,[ebp+var_8]
add eax,1
mov [ebp+var_8],eax
mov eax,[ebp+var_4]
cdq
mov ecx,3
idiv ecx
mov [ebp+var_8],edx

3.识别if语句
C:
int x = 1;
int y = 2;
if(x=y){
  printf("x equal y.\n");
}else{
  printf("x is not equal y.\n");
}:
Asm:
mov [ebp+var_4],1
mov [ebp+var_8],2
mov eax,[ebp+var_8]
cmp eax,[ebp+var_4]
jnz short loc_40102B
push offset aXEqualsY_; "x equal y.\n"
call printf
add esp,4
jmp short loc_401038
loc_40102B:
push offset aXIsNotEqualToY; "x is not equal y.\n"
call printf

4.1.识别for循环
C:
int i;
for(i=0;i<100;i++)
{
  printf("i equal %d\n",i);
}
Asm:
mov [ebp+var_4],0;
jmp shot local_401016
local_40100D:
mov eax,[ebp+var_4]
add eax,1
mov [ebp+var_4],eax
local_401016:
cmp [ebp_var_4],64h
jge shot_local_40102F
mov ecx,[ebp+var_4]
push eax
push offset aID;
call printf
add esp,8
jmp short locla_40100D

4.2.while循环
C:
int status=0;
int result=0;
while(status==0){
  result = performAction();
  status = checkResult(result);
}
Asm:
mov [ebp+var_4],0
mov [ebp,var_8],0
local 401044:
cmp [ebp+var_4],0
jnz short loc_401063
call performAction
mov [ebp+var_8],eax
mov eax,[ebp+var_8]
push eax
call checkResult
add esp,4
mov [ebp_var4],eax
jmp shot loc_401044

5.函数调用约定
C:
int test(int x,int y,int z);
int a,b,c,rst;
rst = test(a,b,c);
[cdecl]:参数从右往左入栈，当函数完成由调用者清理栈，返回值保持在EAX
ASM:
push c
push b
push a
call test
add esp,12
mov ret,eax
[stdcall]:被调用者清理栈
ASM:
push c
push b
push a
call test
mov ret,eax
[fastcall]:部分参数被传到寄存器(EDX和ECX)

6.Switch
C:
switch(i)
{
case 1:
  printf("i = %d",i+1);
  break;
case 2:
  printf("i = %d",i+2);
  break;
case 3:
  printf("i = %d",i+3);
  break;  
default:
  break;
}
Asm[if样式]:
cmp [ebp+var_8],1
jz  short loc_401027
cmp [ebp+var_8],2
jz  short loc_40103D
cmp [ebp+var_8],3
jz  short loc_401053
jmp short loc_401067
loc_401027:
    mov ecx,[ebp+var_4]
    add ecx,1
    push ecx
    push offset unk_40C000
    call printf
    add esp,8
    jmp short loc_401067
loc_40103D:
    mov ecx,[ebp+var_4]
    add ecx,2
    push ecx
    push offset unk_40C004
    call printf
    add esp,8
    jmp short loc_401067   
loc_401053:
    mov ecx,[ebp+var_4]
    add ecx,3
    push ecx
    push offset unk_40C008
    call printf
    add esp,8
Asm[跳转表样式]:    
sub ecx,1
mov [ebp+var_8],ecx
cmp [ebp+var_8],3
ja short loc_401082
mov edx,[ebp+var_8]
jmp ds:off_401088[edx*4]
loc_40102C:
  ...
  jmp short loc_401082
loc_401042:
  ...
  jmp short loc_401082  
loc_401058:
  ...
  jmp short loc_401082  
loc_40106e:
  ...
  jmp short loc_401082  
loc_401082:
  xor eax,eax
  mov esp,ebp
  pop ebp
  retn
_main endp
off_401088  dd  offset loc_40102C
            dd  offset loc_401042
            dd  offset loc_401058
            dd  offset loc_40106E
            
7.反汇编数组
C:
int b[5]={123,87,487,7,798};
void main()
{
int i;
int a[5];
for(i=0;i<5;i++)
{
  a[i]=i;
  b[i]=i;
}
}
Asm:
mov [ebp+var_18],0
jmp short loc_401018
loc_40100F:
mov eax,[ebp+var_18]
add eax,1
mov [ebp+var_18],eax
loc_401018:
cmp [ebp+var_18],5
jge short loc_401037
mov ecx,[ebp+var_18]
mov edx,[ebp+var_18]
mov [ebp+ecv*4+var_14],edx
mov eax,[ebp+var_18]
mov ecx,[ebp+var_18]
mov dword_40A000[ecx*4],eax
jmp short loc_40100F

























