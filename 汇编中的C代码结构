# 汇编中的C代码结构

1.全局与局部变量 
全局变量通过内存地址引用，局部变量通过栈地址引用
全局变量调用：
C:
int x = 1;
int y = 2;
void main()
{
  x = x+y;
  printf("Total=%d\n",x);
}
Asm:
mov eax,dword_40CF60
add eax,dword_40C000
mov dword_40CF60,eax
mov ecx,dword_40CF60
push exc
push offset aTotalD; "total=%d\n"
call printf
局部变量调用：
C:
void main()
{
  int x = 1;
  int y = 2;
  x = x+y;
  printf("Total=%d\n",x);
｝
Asm:
mov dword ptr[ebp-4],1
mov dword ptr[ebp-8],2
mov eax,[ebp-4]
add eax,[ebp-8]
mov [ebp-4],eax
mov ecx,[ebp-4]
push ecx
push offset aTotalD; "total=%d\n"
call printf

2.反汇编算术操作
C:
int a = 0;
int b = 1;
a = a + 11;
a = a - b;
a--;
b++;
b = a % 3;
Asm:
mov [ebp+var_4],0
mov [ebp+var_8],1
mov eax,[ebp+var_4]
add eax,0Bh
mov [ebp+var_4],eax
mov ecx,[ebp+var_4]
sub ecx,[ebp+var_8]
mov [ebp+var_4],ecx
mov edx,[ebp+var_4]
sub edx,1
mov [ebp+var_4],edx
mov eax,[ebp+var_8]
add eax,1
mov [ebp+var_8],eax
mov eax,[ebp+var_4]
cdq
mov ecx,3
idiv ecx
mov [ebp+var_8],edx

3.识别if语句
C:
int x = 1;
int y = 2;
if(x=y){
  printf("x equal y.\n");
}else{
  printf("x is not equal y.\n");
}:
Asm:
mov [ebp+var_4],1
mov [ebp+var_8],2
mov eax,[ebp+var_8]
cmp eax,[ebp+var_4]
jnz short loc_40102B
push offset aXEqualsY_; "x equal y.\n"
call printf
add esp,4
jmp short loc_401038
loc_40102B:
push offset aXIsNotEqualToY; "x is not equal y.\n"
call printf

4.1.识别for循环
C:
int i;
for(i=0;i<100;i++)
{
  printf("i equal %d\n",i);
}
Asm:
mov [ebp+var_4],0;
jmp shot local_401016
local_40100D:
mov eax,[ebp+var_4]
add eax,1
mov [ebp+var_4],eax
local_401016:
cmp [ebp_var_4],64h
jge shot_local_40102F
mov ecx,[ebp+var_4]
push eax
push offset aID;
call printf
add esp,8
jmp short locla_40100D

4.2.while循环
C:
int status=0;
int result=0;
while(status==0){
  result = performAction();
  status = checkResult(result);
}
Asm:
mov [ebp+var_4],0
mov [ebp,var_8],0
local 401044:
cmp [ebp+var_4],0
jnz short loc_401063
call performAction
mov [ebp+var_8],eax
mov eax,[ebp+var_8]
push eax
call checkResult
add esp,4
mov [ebp_var4],eax
jmp shot loc_401044

5.函数调用约定
C:
int test(int x,int y,int z);
int a,b,c,rst;
rst = test(a,b,c);
[cdecl]:参数从右往左入栈，当函数完成由调用者清理栈，返回值保持在EAX
ASM:
push c
push b
push a
call test
add esp,12
mov ret,eax
[stdcall]:被调用者清理栈
ASM:
push c
push b
push a
call test
mov ret,eax
[fastcall]:部分参数被传到寄存器(EDX和ECX)
