virus-exploits

1.引言
1.1混合攻击的定义
1.2威胁

2.背景
Morris

3.漏洞的类型
3.1缓冲区溢出：数据超出了缓冲区的大小
3.2第一代缓冲区溢出攻击：堆栈中的缓冲区溢出
3.2.1堆栈缓冲区溢出
void function(void)
{
  char buffer[256];
  for(i=0;i<512;i++)
    buffer[i]='A';
}
3.2.2堆栈缓冲区溢出的利用：覆盖EIP
3.2.3造成堆栈缓冲区溢出的原因：未检测数据的大小
3.3第二代攻击
3.3.1单字节越界溢出（off-by-one）
#include <stdio.h>
int i;
void vuln(char *foobar)
{
  char buffer[512];
  for(i=0;i<=512;i++) # =溢出
    buffer[i]=foobar[i]
}
void main(int argc,char *argv[])
{
  if(argc==2)
    vuln(argv[1]);
}
3.3.2堆溢出
3.3.3堆
3.3.4有漏洞的代码
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void main(int argc,char **argv)
{
  char *buffer = (char *)malloc(16);
  char *input = (char *)malloc(16()
  strcpy(buffer,"AAAAAAAAAAAAAAAA");
  strcpy(input,argv[1]);
  printf("%s",buffer);
}
3.3.5堆溢出的利用：Linux/Slapper蠕虫
3.3.6函数指针
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int CallBack(const char *szTemp)
{
  printf("CallBack(%s)\n",szTemp);
  return 0;
}
void main(int argc,char **argv)
{
  static char buffer[16];
  static int (*funcptr)(const char *szTemp);
  funcptr = (int (*)(const char *szTemp))CallBack;
  strcpy(buffer,argv[1]);
  (int)(*funcptr)(argv[2]);
｝
3.4第三代攻击
3.4.1格式化字符串攻击
int vuln(char buffer[256])
{
  int nReturn = 0;
  printf(buffer);
  return(nReturn);
}
void main(int argc,char *argv[])
{
  char buffer[256] = "";
  if(argc==2)
  {
    strncpy(buffer,argv[1],255);
  }
  vuln(buffer);
}
3.4.2堆管理
3.4.3输入检查
3.4.4URL编码及规范化：W32/Nimda
3.4.5MIME报头解析
自动解析执行：W32/Badtrans、W32/Klez
3.4.6应用程序权限验证
3.4.7标记为可安全执行的ActiveX控件：VBS/Bubbleboy
3.4.8修改系统：W32/Bolzano
3.4.9网络枚举：W32/ExploreZip、W32/Funlove、W32/HLLW.Bymer、W32/Opaserv蠕虫

4.攻击实例
4.1 1998年的Morris蠕虫（利用堆栈溢出执行shellcode）
4.2 1998年的Linux/ADM
4.3 2001年爆发的CodeRed（代码注入攻击）






