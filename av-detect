# av-detect

杀软使用的各种病毒防御技术：
1>先易后难的介绍计算机病毒检测的例子：
简单的基于模式的病毒检测
精确识别
加密、多态和变形病毒的检测
2>扫描器的两类工作方式：
OAS - on access scan
ODS - on demand scan

1.第一代扫描器
并非所有检测技术都适用于所有病毒，也不应要求每种检测技术都能做到这一点。只要拥有一个技术仓库，其中每种技术都能有效阻止，检测或清除一种特征病毒就足够了。
1.1字符串扫描
字符串扫描是检测计算机病毒最简单的方法。从特定病毒提取特征字节序列（字符串）进行检测；非PE文件一般会做全文搜索。 
0400 B801 020E 07BB 0002 33C9 8BD1 419C
1.2通配符
通配符一般用于跳过某些字节或字节范围，甚至允许正则表达式。
0400 B801 020E 07BB ??02 %3 33C9 8BD1 419C
?? - 忽略
%3 - 接下来的3个位置(字节)尝试匹配33
反向字符串匹配（从后向前字符比较差异）、过滤算法、散列算法等使得扫描速度基本与需要匹配的字符串数目无关。
1.3不匹配字节数
允许字符串中有N个字节为任意值。
1.4通用检测法：应对变种
使用一个简单的字符串来搜索某类病毒的部分/全部已知变种，还需要执行一些特殊代码进行算法检测。当某个病毒有一种以上变种时，就可以比较这些变种以找出其
相同代码区，然后从尽可能多的变种中选出一个简单的特征字符串，一般特征字符串同时使用了“通配符”和“不匹配字节数”技术。
1.5散列
加速搜索算法的技术，对扫描的字符串的首字节或第一个16位/32位字进行计算。TbScan扫描器采用2个散列表和1个字符串表，第一个散列表包含第二个散列表的索引位。
1.6书签
书签也称检验字节(check bytes)是一种保证病毒检测和清除过程更加准确的简单方法。通常AV要计算病毒体的起始位置（常称为病毒体零字节）和特征字符串之间的
距离，并单独保存在病毒检测记录中。
好的书签可以用于具体病毒的清除。
1.7首尾扫描
只扫文件的的头部和尾部，而不扫描整个文件；比如文件开头和结尾的2KB、4KB或8KB。由于CPU的提升，扫描速度主要受I/O速度的限制。
1.8入口点和固定点扫描
二进制可执行文件，大幅降低I/O次数。
1.9超快磁盘访问
直接读取磁盘。

2.第二代扫描器
采用近似精确识别法(nearly exact identification)和精确识别法(exact identification)有助提高检测精度。 
2.1智能扫描(smart scanning)
忽略宿主中像NOP这样的指令；对处理文本格式的病毒（script和macro）也很有用，从扫描缓冲区去除多余的空白字符（如空格、回车/换行符和制表符等）；熵。
2.2骨架扫描法(skeleton scanning)
检测宏病毒，去非必要和空白字符保留宏代码骨架，从而提高检测同一家族不同变种的能力。
2.3近似精确识别法(nearly exact identification)
一种方法是采用两个字符串（而不是一个）来检测每个病毒；另一个方法是从病毒体中选出一个范围计算其效验和（如CRC32）。
2.4精确识别法(exact identification)
保证精确识别变种的唯一方法。
近似精确法仅计算病毒体中一块恒值字节区域的效验和，精确识别法则计算病毒体中全部恒值比特(bit)的效验和，必须删除病毒体中非恒值字节（变形的变量名等），
以生成一特征图张只包括所有恒值字节的特征图(map)。特征图中只能用恒值字节，因为可变数据会影响到效验和。

3.算法扫描方法
特定病毒的专用检测算法(virus-specific detection algorithm)
采用病毒扫描语言(virus scanning language),这种语言允许对被扫描对象执行寻位(seek)和读(read)操作。因此这种算法可以如此进行：从文件头正向扫描、或从
文件尾反向扫描、或从入口点开始扫描，一直寻找到一个特定位置。
3.1过滤法(filtering):W32/Gobi、W95/Zmist
3.2静态解密程序检测法：W95/Mad
3.3X光检测法：W95/Drill、W95/SK
for(p=0;p<0x700;p++)
{
  ch1 = buf[p]; ch1 = buf[p+1];
  k1 = ch1^0xE8;q1 = ch2-k1;
  k2 = ch1-0xE8;q2 = ch2-k2;
  k3 = k1;q3 = ch2-ch1;
  k4 = (-ch1)^0xE8;q4=-ch2-k4;
  k5 = cha1^0xFF^0xE8;q5=(ch2^0xFF)-k5; /*XOR FF = NOT*/
  
  for(i=0;i<0x40;i++)
  {
    ch1 = buf[ptr+i];
    buf[0x800+i]=ch1^k1;k1+=q1;
    buf[0x900+i]=ch1-k2;k2+=q2;
    buf[0xA00+i]=ch1^k3;k3=ch1+q3;
    buf[0xB00+i]=(-ch1)^k4;k4+=q4;
    buf[0xC00+i]=ch1^k5^0xFF;k5+=q5; /*XOR FF = NOT*/
  }
  
  for(i=0x800;i<=0xC00;i+=0x100)
  {
    if(((uint32*)(buf+1))[0]==0x580000E8 &&
      ((unit32*)(buf+1))[1]==0x04B1CCFE)
    {
      // Complete identification attemp here
    }
  }
}

4、代码仿真
该技术实现了一个虚拟机来仿真CPU和内存管理系统，进而模拟代码执行过程。
例子：C实现16位IntelCPU的寄存器和标志位
Typedef struct{
  byte ah,al,bh,bl,ch,cl,dh,dl;
  word si,di,sp,bp,cs,ds,es,ss,ip;}Emulator_Registers_t;
Typedef struct{
  byte c,z,p,s,o,d,i,t,a;}Emulator_Flags_t;
代码仿真的目的是用虚拟寄存器和标志位来模拟CPU的指令集。
例子：16位CPU仿真器代码片段
opcode=read_mem(absadr(CPU->reg.ip,SEGM_CS,0))
while(condition(opconde)&&(!CpuError))
{
  switch(opcode)
  {
    // All opcode listed here only one by one
    // Only two examples are shown here
    :
    :
  case 0x90; /* NOP instruction */
    my_ip++;
    break;
    :
    :
  case 0xCD: /* INT instruction - execute an interrupt */
    emulator_init_interrupt_stack();
    emu_int(code,read_mem(absadr(CPU->reg.ip+1;SEGM_CS,0)));
    my_ip++=2;
  break;
    :
    :
  }
CPU->reg.ip+=my_ip;
CPU->iterations++;
opcode=read_mem(absadr(CPU->reg.ip,SEGM_CS,0));
}

/* Emulate Interrupts */
void emu_int(byte opcode,byte opcode2)
{
  // DOS Version check?
  if(opcode==0xcd && opcode2==0x21 && CPU->reg.ah==0x30)
  {
    CPU->reg.al = 3; CPU->reg.ah = 38; // DOS 3.38,wht not?
    return;
  }
  :
  :
}
如何可以停止仿真器运行？
>跟踪活跃指令(active instruction)
活跃指令是指那些修改虚拟内存中8位/16位或32位数值的指令。“对相邻位置进行修改”是多态病毒在内存中解密时的典型特征。
>用特征图(profile)跟踪解密程序
>用断点来停止
可以为仿真器预设几个断点作为停止条件
4.1用代码仿真来检测加密和多态病毒
代码仿真的关键思想就是其“试验及错误”检测法(trial-and-error detection)。
4.2动态解密程序检测法

5.变形病毒检测实例
5.1几何检测法(geometric detection)
根据病毒对文件结构所做的改变来检测病毒的技术。W95/Zmist
5.2反汇编技术
反汇编就是指把代码流拆分为单个的指令，只关注感兴趣的指令。W95/Puron
5.3采用仿真器进行跟踪
5.3.1ACG病毒样本的检测
MOV AX, 65A1
XCHG DX, AX
MOV AX, DX
MOV BP, AX
ADD EBP, 69BDAA5F
MOV BX, BP
XCHG BL, DH
MOV BL, BYTE PTR DS:[43A5]
XCHG BL, DH
CMP BYTE PTR GS:[B975], DH
SUB DH, BYTE PTR DS:[6003]
MOV AH, DH
INT 21
当执行到INT 21时，寄存器ah=4a而bx=1000。这个取值对于ACG类病毒时固定的。
5.3.2Evol病毒样本的检测
5.3.3采用阴性特征和阳性特征
5.3.4采用基于仿真器的启发式检测法
启发式检测不能识别出是哪个具体病毒，但可以提取病毒的特征和检测病毒的类型。

6.32位Windows病毒的启发式分析
二进制病毒的启发式检测一般是通过仿真运行程序，然后寻找可疑的代码组合。W95/Marburg或W95/HPS
6.1代码从最后一节开始执行
6.2节头部可疑的属性
6.3PE可选头部有效尺寸的值不正确
6.4节之间的“间隙”（W95/Boza和W95/Memorial）
6.5可疑的代码重定向：入口点跳转(JMP)到其它节
6.6可疑的代码节名称
6.7可能的头部感染
6.8来自KERNEL32.DLL的基于序号的可疑导入表项
6.9导入地址表被修改
6.10多个PE头部
6.11多个Windows程序头部和可疑的Kernel32.dll导入表项
6.12可疑的重定位信息
6.13内核查询
6.14内核的完整性
6.15把节装入到VMM的地址空间
6.16可选头部的SizeOfCode域取值不正确
6.17含有多个可疑标志的例子(W32/Cabanas,W95/Anxiety,W95/Marburg,W95/SGWW)

7.基于神经网络的启发式分析

8.常规及通用清除法
8.1标准清除法
8.2通用解密程序(generic decryptor)
8.3通用清除程序如何工作
8.4清除程序如何确定一个文件是否染毒
8.5宿主文件原来的结尾在哪里
8.6能用这种方法清除的病毒有多少类
8.6.1引导扇区病毒
8.6.2文件病毒
8.7通用修复法中的启发性标记实例
8.8通用清除过程实例
高级启发式清除器(Advanced Heuristic Disinfector，AHD)的启发性标志(heuristic flag)包括：
>加密：程序中发现一个代码解密函数(code decryptor function)
>打开现有文件（读/写）
>可疑的文件访问
>时间/日期触发例程
>内存驻留代码
>中断钩子
>未公开的中断调用
>内存中的重定位
>寻找内存的大小
>自我重定位(self-relocating)代码
>查找文件的代码
>奇怪的内存分配
>复制
>反调试
>直接磁盘存取
>使用未公开的DOS功能
>确实是EXE还是COM
>程序装入陷阱
>访问CMOS
>传染源代码
8.8通用清除过程实例

9.接种

10.访问控制系统

11.完整性检查
11.1虚警
11.2干净的初始状态
11.3速度
11.4特殊对象
11.5必须用对象发生改变




  








